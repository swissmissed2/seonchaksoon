# seonchaksoon – 선착순 쿠폰 발급 시스템

동시 요청 환경에서 **쿠폰 중복·초과 발급을 방지**하고,  
여러 동시성 제어 전략을 직접 구현하고 부하 테스트를 통해 비교한 프로젝트입니다.

---

## 프로젝트 목적

- 다수의 사용자가 동시에 요청하는 상황에서  
  **정해진 수량만 정확히 발급되는 선착순 로직 구현**
- 단일 서버 환경을 넘어 **분산 환경에서도 정합성을 보장하는 방법 탐구**
- 동시성 제어 방식별 **성능, 지연, 운영 안정성 차이 비교**

---

## 동시성 제어 방식별 구현

### 1. Java `synchronized`
- JVM 내부 락 기반 동기화
- 단일 서버 환경에서는 동작 가능
- 멀티 인스턴스 환경에서는 락 공유 불가
- 요청 증가 시 애플리케이션 레벨 병목 발생

---

### 2. Database Lock

#### Pessimistic Lock
- `SELECT ... FOR UPDATE` 기반 Row Lock
- DB가 대기 큐를 관리하여 정합성 보장
- 요청이 몰릴수록 지연 증가 및 처리량 감소

#### Optimistic Lock
- 버전 컬럼 기반 충돌 감지
- 락 대기 없이 충돌 시 즉시 실패
- 재시도 정책에 따라 성능 특성 변화
- 높은 처리량과 낮은 지연 시간

#### Named Lock
- DB의 `GET_LOCK` / `RELEASE_LOCK` 활용
- 트랜잭션과 분리된 락 관리
- 분산 환경에서도 락 공유 가능
- DB 커넥션을 점유하므로 트래픽 증가 시 병목 발생 가능

---

### 3. Redis 기반 Lock

#### Spin Lock (Lettuce)
- Redis `SET NX` 기반 직접 구현
- 락 획득까지 반복 요청(바쁜 대기)
- Redis 및 CPU 부하 증가 가능
- 트래픽 증가 시 운영 리스크 존재

#### Redisson Lock
- Redis Pub/Sub 기반 대기 방식
- 불필요한 반복 요청 제거
- Watchdog을 통한 TTL 자동 연장
- 성능과 안정성의 균형이 가장 뛰어남

---

## 부하 테스트

### 테스트 환경
- 부하 도구: k6
- 동시 사용자(VUS): 20
- 테스트 시간: 10초
- 쿠폰 발급 수량(limit): 100
- 모든 테스트는 동일 조건에서 수행

---

## 테스트 결과 요약

### 정합성
- 모든 정상 전략에서 **정확히 100건만 발급**
- 중복 발급 및 초과 발급 없음
- `synchronized` 방식은 지연 및 503 에러로 실패

### 성능 비교

| 방식 | 처리량 | 지연(p95) | 안정성 | 비고 |
|----|----|----|----|----|
| synchronized | 매우 낮음 | 매우 높음 | 낮음 | 단일 서버 한계 |
| Pessimistic Lock | 낮음 | 높음 | 보통 | DB Row Lock |
| Named Lock | 보통 | 보통 | 보통 | DB 커넥션 점유 |
| Optimistic Lock | 높음 | 낮음 | 보통 | 실패율 높음 |
| Redis Spin Lock | 높음 | 낮음 | 낮음 | Redis 부하 |
| Redisson Lock | 높음 | 낮음 | 높음 | 최종 선택 |

---

## 설계 결론

Optimistic Lock은 가장 높은 처리량과 낮은 지연 시간을 제공했지만,  
실패율이 높아 비즈니스 요구에 따라 적합성이 달라질 수 있었습니다.  
Named Lock과 Pessimistic Lock은 정합성은 우수했으나  
DB 자원 점유로 인해 트래픽 증가 시 병목이 발생했습니다.  

Redisson Lock은 선착순 정합성을 유지하면서도  
성능과 운영 안정성의 균형이 가장 뛰어난 방식으로 판단하여 최종 선택했습니다.

---

## 핵심 학습 포인트

- 선착순 시스템의 핵심은 절대적인 순서 보장이 아닌 **정합성 유지**
- 동시성 제어 방식은 환경(단일/분산)과 트래픽 특성에 따라 달라져야 함
- Database Lock과 Redis Lock은 **병목 지점이 다름**
- Redis Lock도 구현 방식에 따라 성능과 안정성이 크게 달라짐
- 기술 선택의 근거를 **실험 결과로 설명하는 것이 중요**

---

## Tech Stack

- Java
- Spring Boot
- JPA / Hibernate
- MySQL
- Redis (Lettuce, Redisson)
- k6
