# seonchaksoon – 선착순 쿠폰 발급 시스템

동시 요청 환경에서 쿠폰의 **중복·초과 발급을 방지**하기 위해  
여러 동시성 제어 방식을 직접 구현하고, 부하 테스트를 통해  
각 방식의 특성과 한계를 비교한 프로젝트입니다.

---

## 프로젝트 목적

- 다수의 사용자가 동시에 요청하는 선착순 이벤트 상황에서  
  **정해진 수량만 정확히 발급되는 로직 구현**
- 단일 서버를 넘어 **분산 환경에서도 동작 가능한 동시성 제어 방식 탐구**
- 단순 구현이 아닌, **부하 테스트 결과를 기반으로 한 기술 선택 근거 확보**

---

## 동시성 제어 방식

### Java `synchronized`
- JVM 내부 락 기반 동기화
- 단일 서버 환경에서는 동작 가능
- 멀티 인스턴스 환경에서는 락 공유 불가
- 부하 증가 시 스레드 BLOCKED로 서비스 붕괴

---

### Database Lock

#### Pessimistic Lock
- `SELECT ... FOR UPDATE` 기반 Row Lock
- DB가 대기 큐를 관리하여 정합성 보장
- 요청 증가 시 DB 락 대기로 지연 및 처리량 감소

#### Optimistic Lock
- 버전 컬럼 기반 충돌 감지
- 락 대기 없이 충돌 시 즉시 실패
- 높은 처리량과 낮은 지연 시간
- 실패율이 높아 비즈니스 요구에 따라 적합성 달라짐

#### Named Lock
- DB `GET_LOCK` 기반 전역 락
- 분산 환경에서 락 공유 가능
- DB 커넥션 점유로 인해 트래픽 증가 시 병목 발생

---

### Redis 기반 Lock

#### Spin Lock (Lettuce)
- Redis `SET NX` 기반 직접 구현
- 락 획득까지 반복 요청(바쁜 대기)
- 처리량은 높으나 Redis/CPU 부하 증가
- 부하 증가 시 비정상 응답 발생 가능

#### Redisson Lock
- Redis Pub/Sub 기반 대기 방식
- 불필요한 반복 요청 제거
- Watchdog을 통한 TTL 자동 연장
- 분산 환경에서 안정적인 락 관리 가능

---

## 부하 테스트

### 테스트 환경
- 부하 도구: k6
- 테스트 시간: 10초
- 쿠폰 발급 수량(limit): 100
- 모든 전략은 동일 조건에서 테스트 수행

### 테스트 시나리오
- 1차: VUS = 20 (기본 성향 확인)
- 2차: VUS = 200, 500 (폭주 상황 검증)

---

## 테스트 결과 요약

### 정합성
- 정상 동작한 모든 전략에서 **정확히 100건만 발급**
- 중복 발급 및 초과 발급 없음
- `synchronized` 방식은 부하 증가 시 503 에러와 함께 서비스 붕괴

### 성능 및 안정성 비교

| 방식 | 처리량 | 지연(p95) | 안정성 | 비고 |
|----|----|----|----|----|
| synchronized | 매우 낮음 | 매우 높음 | 낮음 | 단일 JVM 한계 |
| Pessimistic Lock | 낮음 | 높음 | 보통 | DB 락 대기 |
| Named Lock | 보통 | 높음 | 보통 | DB 커넥션 점유 |
| Optimistic Lock | 매우 높음 | 낮음 | 보통 | 실패율 높음 |
| Redis Spin Lock | 높음 | 낮음 | 낮음 | Redis 부하 |
| Redisson Lock | 높음 | 보통 | 높음 | 분산 환경에 적합 |

---

## 결론

낮은 부하 환경에서는 Optimistic Lock이 가장 높은 처리량과 낮은 지연 시간을 보였다.  
그러나 동시 사용자 수를 200 이상으로 증가시키자 일부 전략은  
503 에러 또는 비정상 응답이 발생하며 안정성이 저하되었다.

Redisson Lock은 처리량이 최상은 아니었지만,  
부하가 증가해도 서비스가 붕괴하지 않고 안정적으로 동작했으며  
분산 환경에서의 락 관리와 운영 안정성 측면에서 가장 균형 잡힌 선택으로 판단했다.

본 프로젝트에서는  
**“가장 빠른 방식”이 아닌 “폭주 상황에서도 버틸 수 있는 방식”을 최종 선택 기준으로 삼았다.**

---

## 핵심 인사이트

- 선착순 시스템은 요청을 정확한 시간 순서로 정렬하는 문제라기보다,  
  **동시 요청 상황에서 정해진 수량을 초과하지 않도록 보장하는 문제에 가깝다**
- 동일한 기능이라도 **락의 대기 방식(블로킹, 스핀, 알림 기반)**에 따라  
  시스템의 성능 특성과 안정성이 크게 달라진다는 것을 실험을 통해 확인했다
- 처리량이 높더라도 **부하 증가 시 에러가 발생하거나 지연이 급증하면**  
  운영 환경에서는 신뢰하기 어려운 설계가 된다
- 분산 환경에서는 특정 락 구현 자체보다,  
  **어디에서 병목이 발생하고 어떤 자원이 먼저 한계에 도달하는지**를 이해하는 것이 더 중요하다


---

## Tech Stack

- Java
- Spring Boot
- JPA / Hibernate
- MySQL
- Redis (Lettuce, Redisson)
- k6
